DP:
(一)概念总结
1.Bellman-Ford 算法也可以在无向图中run，但是此时要保证图中不能有负边，但是因为它的时间复杂度是O(VE),所以不如果Dijkstr。
2.强制在有负圈的图中run Bellman-ford其实也可以得到部分点的准确最短距离
3.所有的DP问题，如果用iteration来求解，就必须从base case来计算，如果题目提供的变量不满足我们填表的顺序，就需要对这种变量进行排序（15 fall最后一道DP题）

(二）题型总结
DP问题从问题本身的解决方式来分，分为选不选问题和问题的缩放两种类型。
其中背包问题属于选不选问题，断点问题属于缩放问题。

DP问题——backtracking思路：就是看从最优解的位置判断它是等于之前的那个子问题的最优解，如果找到了这个子问题，那就pop出这个子问题的坐标，然后重复这个过程，直到base-case

DP问题——时间复杂度的计算：
简单的方法是：写处伪代码，看出有几个loop，和每次loop的时间、
或者: 先考虑有多少个子问题（或者说有是一张多大的表格要填写），然后看每个子问题的处理时间是多少（也就是调写表格中的每个cell要多少时间）
全部问题的时间复杂度，针对题目的要求，也就是题目准确想要的最优解在表格中的位置，可以把去不问题的时间复杂度减少化解

（DP中需要注意的问题是不要忽略initialization和对 recurrence Formula 的limitation的考虑）

下面是一些含有明显特征的题型总结和大致解题思路
